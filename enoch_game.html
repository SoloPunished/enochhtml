<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ENOCH 0.011</title>
  <style>
    canvas {
      border: 2px solid #000;
      background: #eee;
      display: block;
      margin: 0 auto;
    }
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      margin: 10px 0;
    }
    #counters {
      display: flex;
      justify-content: center;
      gap: 40px;
      font-size: 20px;
      margin: 10px auto;
      width: fit-content;
    }
    #levelText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: black;
      background: rgba(255, 255, 255, 0.8);
      padding: 20px;
      border-radius: 10px;
      display: none;
      z-index: 10;
    }
    #upgradeMenu {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 10;
    }
  </style>
</head>
<body>
  <h1>ENOCH</h1>
  <canvas id="game" width="500" height="500"></canvas>
  <div id="counters">
    <span id="deathCounter">Deaths: 0</span>
    <span id="levelCounter">Level: 1 | Max: 1</span>
    <span id="sessionTimer">Session Time: 00:00</span>
  </div>
  <div id="levelText"></div>
  <div id="upgradeMenu">
    <h2>Choose an Upgrade</h2>
    <button id="healthUpgrade">Increase Health</button>
    <button id="damageUpgrade">Increase Damage</button>
    <button id="confirmUpgrade">Confirm</button>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const levelText = document.getElementById("levelText");
    const deathCounterText = document.getElementById("deathCounter");
    const levelCounter = document.getElementById("levelCounter");
    const sessionTimer = document.getElementById("sessionTimer");

    let deaths = 0;
    let maxPlayerLevel = 1;
    let gameLevel = 1;
    let gridSize = 5;
    const tileSize = 100;
    let sessionStartTime = Date.now();
    let enemies = [], heals = [], powerUps = [], dropFlashes = [], healingArrows = [];
    let player = {};
    let playerImage = null;
    let showStatText = null;

    const persistentStats = { health: 10, damage: 3 };
    let sessionStats = { health: 10, damage: 3 };

    const gameAssets = {};
    const imagePaths = {
      attackPointUp: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/attack%20point%20up.png",
      boss: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/boss.png",
      enemy: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/enemy.png",
      player: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/player.png",
      healthPointUp: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/health%20point%20up.png",
      playerAttack: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/player%20attack.png",
      playerDeath: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/player%20death.png"
    };

    function loadImages(callback) {
      let loaded = 0;
      const total = Object.keys(imagePaths).length;
      for (const [key, path] of Object.entries(imagePaths)) {
        const img = new Image();
        img.onload = () => {
          if (++loaded === total) callback();
        };
        img.src = path;
        gameAssets[key] = img;
      }
    }

    function drawTextWithOutline(text, x, y, color = "white") {
      ctx.font = "bold 16px Arial";
      ctx.lineWidth = 3;
      ctx.strokeStyle = "black";
      ctx.strokeText(text, x, y);
      ctx.fillStyle = color;
      ctx.fillText(text, x, y);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
        }
      }

      enemies.forEach(e => {
        ctx.drawImage(gameAssets.enemy, e.x * tileSize, e.y * tileSize, tileSize, tileSize);
        drawTextWithOutline(`${e.hp}`, e.x * tileSize + 10, e.y * tileSize + 20, "yellow");
        drawTextWithOutline(`${e.atk}`, e.x * tileSize + 10, e.y * tileSize + tileSize - 10, "orange");
      });

      ctx.drawImage(playerImage, player.x * tileSize, player.y * tileSize, tileSize, tileSize);
      drawTextWithOutline(`${player.hp}/${player.maxHp}`, player.x * tileSize + 10, player.y * tileSize + 20, "cyan");
      drawTextWithOutline(`${player.atk}`, player.x * tileSize + 10, player.y * tileSize + tileSize - 10, "red");
    }

    function getRandomEmptyTile() {
      let x, y;
      do {
        x = Math.floor(Math.random() * gridSize);
        y = Math.floor(Math.random() * gridSize);
      } while ((x === player.x && y === player.y) || enemies.some(e => e.x === x && e.y === y));
      return { x, y };
    }

    function spawnEnemies() {
      enemies = [];
      const count = Math.floor((gameLevel * 1.5) + 1);
      for (let i = 0; i < count; i++) {
        const pos = getRandomEmptyTile();
        enemies.push({
          x: pos.x,
          y: pos.y,
          hp: 3 * (2 ** (gameLevel - 1)),
          atk: 1 * (2 ** (gameLevel - 1))
        });
      }
    }

    function initGame() {
      sessionStats = { health: persistentStats.health, damage: persistentStats.damage };
      player = { x: 2, y: 2, hp: sessionStats.health, maxHp: sessionStats.health, atk: sessionStats.damage, lvl: 1 };
      gameLevel = 1;
      maxPlayerLevel = 1;
      playerImage = gameAssets.player;
      spawnEnemies();
      updateCounters();
      draw();
    }

    function resetGame() {
      if (player.lvl > maxPlayerLevel) maxPlayerLevel = player.lvl;
      deaths++;
      sessionStats = { health: persistentStats.health, damage: persistentStats.damage };
      player = { x: 2, y: 2, hp: sessionStats.health, maxHp: sessionStats.health, atk: sessionStats.damage, lvl: 1 };
      gameLevel = 1;
      playerImage = gameAssets.player;
      spawnEnemies();
      updateCounters();
      showLevelTextMsg("GAME OVER");
      setTimeout(() => {
        showLevelTextMsg("LEVEL 1");
        draw();
      }, 2000);
    }

    function updateCounters() {
      deathCounterText.textContent = `Deaths: ${deaths}`;
      levelCounter.textContent = `Level: ${gameLevel} | Max: ${maxPlayerLevel}`;
    }

    function updateSessionTimer() {
      const now = Date.now();
      const totalSeconds = Math.floor((now - sessionStartTime) / 1000);
      const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
      const seconds = String(totalSeconds % 60).padStart(2, '0');
      sessionTimer.innerText = `Session Time: ${minutes}:${seconds}`;
    }

    function showLevelTextMsg(text) {
      levelText.innerText = text;
      levelText.style.display = "block";
      setTimeout(() => {
        levelText.style.display = "none";
      }, 2000);
    }

    function attackEnemyAt(x, y) {
      const target = enemies.find(e => e.x === x && e.y === y);
      if (target) {
        playerImage = gameAssets.playerAttack;
        target.hp -= player.atk;
        setTimeout(() => { playerImage = gameAssets.player; }, 300);

        if (target.hp <= 0) {
          enemies = enemies.filter(e => e !== target);
          player.lvl++;
          if (enemies.length === 0) {
            gameLevel++;
            spawnEnemies();
            showLevelTextMsg(`LEVEL ${gameLevel}`);
          }
        } else {
          player.hp -= target.atk;
          if (player.hp <= 0) resetGame();
        }
      }
    }

    document.addEventListener("keydown", (e) => {
      let moved = false;
      const dx = (["ArrowLeft", "a", "A"].includes(e.key)) ? -1 :
                 (["ArrowRight", "d", "D"].includes(e.key)) ? 1 : 0;
      const dy = (["ArrowUp", "w", "W"].includes(e.key)) ? -1 :
                 (["ArrowDown", "s", "S"].includes(e.key)) ? 1 : 0;

      if (dx !== 0 || dy !== 0) {
        const newX = player.x + dx;
        const newY = player.y + dy;

        if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize) {
          const enemyThere = enemies.find(e => e.x === newX && e.y === newY);
          if (enemyThere) {
            attackEnemyAt(newX, newY);
          } else {
            player.x = newX;
            player.y = newY;
            moved = true;
          }
        }
      }

      if (moved) draw();
    });

    document.getElementById("healthUpgrade").addEventListener("click", () => {
      persistentStats.health++;
      sessionStats.health = persistentStats.health;
      player.hp = sessionStats.health;
      player.maxHp = sessionStats.health;
    });

    document.getElementById("damageUpgrade").addEventListener("click", () => {
      persistentStats.damage++;
      sessionStats.damage = persistentStats.damage;
      player.atk = sessionStats.damage;
    });

    document.getElementById("confirmUpgrade").addEventListener("click", () => {
      document.getElementById("upgradeMenu").style.display = "none";
    });

    function checkForUpgradeMenu() {
      if (gameLevel % 2 === 0) {
        document.getElementById("upgradeMenu").style.display = "block";
      }
    }

    function gameLoop() {
      updateSessionTimer();
      draw();
      requestAnimationFrame(gameLoop);
    }

    loadImages(() => {
      initGame();
      gameLoop();
    });

    setInterval(checkForUpgradeMenu, 1000);
  </script>
</body>
</html>
