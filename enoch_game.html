<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ENOCH 0.011</title>
  <style>
    canvas {
      border: 2px solid #000;
      background: #eee;
      display: block;
      margin: 0 auto;
    }
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      margin: 10px 0;
    }
    #counters {
      display: flex;
      justify-content: center;
      gap: 40px;
      font-size: 20px;
      margin: 10px auto;
      width: fit-content;
    }
    #levelText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: black;
      background: rgba(255, 255, 255, 0.8);
      padding: 20px;
      border-radius: 10px;
      display: none;
      z-index: 10;
    }
    #upgradeMenu {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 10;
    }
  </style>
</head>
<body>
  <h1>ENOCH</h1>
  <canvas id="game" width="400" height="400"></canvas>
  <div id="counters">
    <span id="deathCounter">Deaths: 0</span>
    <span id="levelCounter">Level: 1 | Max: 1</span>
    <span id="sessionTimer">Session Time: 00:00</span>
  </div>
  <div id="levelText"></div>
  <div id="upgradeMenu">
    <h2>Choose an Upgrade</h2>
    <button id="healthUpgrade">Increase Health</button>
    <button id="damageUpgrade">Increase Damage</button>
    <button id="confirmUpgrade">Confirm</button>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const levelText = document.getElementById("levelText");
    const deathCounterText = document.getElementById("deathCounter");
    const levelCounter = document.getElementById("levelCounter");
    const sessionTimer = document.getElementById("sessionTimer");

    let deaths = 0;
    let maxPlayerLevel = 1;
    let gameLevel = 1;
    let gridSize = 5;
    const tileSize = 100;
    let sessionStartTime = Date.now();
    let enemies = [], heals = [], powerUps = [], dropFlashes = [], healingArrows = [];
    let player = {};
    let showStatText = null;

    const persistentStats = { health: 10, damage: 3 };
    let sessionStats = { health: 10, damage: 3 };

    const gameAssets = {};
    const imagePaths = {
      attackPointUp: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/attack%20point%20up.png",
      boss: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/boss.png",
      enemy: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/enemy.png",
      player: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/player.png",
      healthPointUp: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/health%20point%20up.png",
      playerAttack: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/player%20attack.png",
      playerDeath: "https://raw.githubusercontent.com/SoloPunished/enochhtml/main/player%20death.png"
    };

    function loadImages(callback) {
      let loaded = 0;
      const total = Object.keys(imagePaths).length;
      for (const [key, path] of Object.entries(imagePaths)) {
        const img = new Image();
        img.onload = () => {
          if (++loaded === total) callback();
        };
        img.src = path;
        gameAssets[key] = img;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
        }
      }
      
      // Player
      ctx.drawImage(gameAssets.player, player.x * tileSize, player.y * tileSize, tileSize, tileSize);
      ctx.fillStyle = "blue";
      ctx.font = "16px Arial";
      ctx.fillText(`${player.hp}/${player.maxHp}`, player.x * tileSize + 10, player.y * tileSize + 20);
      ctx.fillStyle = "red";
      ctx.fillText(player.atk, player.x * tileSize + 10, player.y * tileSize + tileSize - 10);

      // Enemies
      enemies.forEach(e => {
        ctx.drawImage(gameAssets.enemy, e.x * tileSize, e.y * tileSize, tileSize, tileSize);
        ctx.fillStyle = "yellow";
        ctx.fillText(e.hp, e.x * tileSize + 10, e.y * tileSize + 20);
        ctx.fillStyle = "orange";
        ctx.fillText(e.atk, e.x * tileSize + 10, e.y * tileSize + tileSize - 10);
      });
    }

    function getRandomEmptyTile() {
      let x, y;
      do {
        x = Math.floor(Math.random() * gridSize);
        y = Math.floor(Math.random() * gridSize);
      } while (
        (x === player.x && y === player.y) ||
        enemies.some(e => e.x === x && e.y === y)
      );
      return { x, y };
    }

    function spawnEnemies() {
      enemies = [];
      const count = Math.floor((gameLevel * 1.5) + 1);
      for (let i = 0; i < count; i++) {
        const pos = getRandomEmptyTile();
        enemies.push({
          x: pos.x,
          y: pos.y,
          hp: 3 * (2 ** (gameLevel - 1)),
          atk: 1 * (2 ** (gameLevel - 1))
        });
      }
    }

    function initGame() {
      sessionStats = {
        health: persistentStats.health,
        damage: persistentStats.damage
      };
      player = {
        x: 2, y: 2,
        hp: sessionStats.health,
        maxHp: sessionStats.health,
        atk: sessionStats.damage,
        lvl: 1
      };
      gameLevel = 1;
      maxPlayerLevel = 1;
      spawnEnemies();
      updateCounters();
      draw();
    }

    function resetGame() {
      if (player.lvl > maxPlayerLevel) maxPlayerLevel = player.lvl;
      deaths++;
      sessionStats = {
        health: persistentStats.health,
        damage: persistentStats.damage
      };
      player = {
        x: 2, y: 2,
        hp: sessionStats.health,
        maxHp: sessionStats.health,
        atk: sessionStats.damage,
        lvl: 1
      };
      gameLevel = 1;
      spawnEnemies();
      updateCounters();
      showLevelTextMsg("GAME OVER");
      setTimeout(() => {
        showLevelTextMsg("LEVEL 1");
        draw();
      }, 2000);
    }

    function updateCounters() {
      deathCounterText.textContent = `Deaths: ${deaths}`;
      levelCounter.textContent = `Level: ${gameLevel} | Max: ${maxPlayerLevel}`;
    }

    function updateSessionTimer() {
      const now = Date.now();
      const totalSeconds = Math.floor((now - sessionStartTime) / 1000);
      const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
      const seconds = String(totalSeconds % 60).padStart(2, '0');
      sessionTimer.innerText = `Session Time: ${minutes}:${seconds}`;
    }

    function showLevelTextMsg(text) {
      levelText.innerText = text;
      levelText.style.display = "block";
      setTimeout(() => {
        levelText.style.display = "none";
      }, 2000);
    }

    function checkForUpgradeMenu() {
      if (gameLevel % 2 === 0) {
        document.getElementById("upgradeMenu").style.display = "block";
      }
    }

    // Upgrade Event Listeners
    document.getElementById("healthUpgrade").addEventListener("click", () => {
      persistentStats.health++;
      sessionStats.health = persistentStats.health;
      player.hp = sessionStats.health;
      player.maxHp = sessionStats.health;
    });

    document.getElementById("damageUpgrade").addEventListener("click", () => {
      persistentStats.damage++;
      sessionStats.damage = persistentStats.damage;
      player.atk = sessionStats.damage;
    });

    document.getElementById("confirmUpgrade").addEventListener("click", () => {
      document.getElementById("upgradeMenu").style.display = "none";
    });

    // Main game loop
    function gameLoop() {
      updateSessionTimer();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Load images and start
    loadImages(() => {
      initGame();
      gameLoop();
    });

    setInterval(checkForUpgradeMenu, 1000);

        document.addEventListener("keydown", (e) => {
      let moved = false;
      if (["ArrowUp", "w", "W"].includes(e.key)) {
        if (player.y > 0) {
          player.y--;
          moved = true;
        }
      } else if (["ArrowDown", "s", "S"].includes(e.key)) {
        if (player.y < gridSize - 1) {
          player.y++;
          moved = true;
        }
      } else if (["ArrowLeft", "a", "A"].includes(e.key)) {
        if (player.x > 0) {
          player.x--;
          moved = true;
        }
      } else if (["ArrowRight", "d", "D"].includes(e.key)) {
        if (player.x < gridSize - 1) {
          player.x++;
          moved = true;
        }
      }

      if (moved) {
        draw();
        // You could insert combat or pickup logic here
      }
    });
  </script>
</body>
</html>
